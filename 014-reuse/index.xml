<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>再利用のはなし on Message Passing</title>
    <link>https://messagepassing.github.io/014-reuse/</link>
    <description>Recent content in 再利用のはなし on Message Passing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://messagepassing.github.io/014-reuse/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>あんまり考えてないよね</title>
      <link>https://messagepassing.github.io/014-reuse/04-jmuk/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/014-reuse/04-jmuk/</guid>
      <description>オープンソースなのにわりかし再発明しがち勢として @jmuk どうですか。
 というふうに（内部的に）話題をふられてしまった。再利用ねえ。あんまり考えてないよね。
Chromiumはモノリシックなコードベースだけど、もちろんいろんな他のライブラリを再利用している。だいたい third_party というところに、そういうのは押し込められている。再利用のためには、ソースコードをもってきて、自分たち用にビルドするという立場。システムに入っているライブラリ（DLL）を再利用する、みたいなことはやらない。バージョンの互換性とかABIの互換性とかがしんどすぎるから。まぁこれは普通か。
ChromiumはGNという独自のビルドシステムでビルドするが（ここがすでに独自なのかよ、というツッコミがあるかもしれませんがスルーしてください）、独自なのでこれをあらかじめサポートしている外部ライブラリというものは、事実上存在しない。なので外部ライブラリを利用するときは誰かがChromium用にGNを書かないといけない。誰かというか、だいたいはそのライブラリを使いたくてthird_partyに足したい人が自分で書くことになる。めんどうくさい。外部ライブラリはgit submodule的なものでリビジョンが指定されていて、uprevするときはGNファイルも微調整する必要がある。細かいビルドフラグの話などもあり、たまに妙な問題を引き起こしたりする（が、昔使われていたGYPよりはだいぶマシになった）。というように細々とした苦労があり、そこは別に乗り越えられていない。たんにたくさんの人がChromiumプロジェクトに雇用されているので、そのうちの誰かに頑張ってもらっているというだけ。
フレームワークという点でいうと、そういえば Chrome / ChromeOS は既存のGUIフレームワーク（gtk+とかWxとか）を使っていない。viewsという独自のGUIフレームワークが内部にあり、これを使ってUIは書かれている。viewsはバックエンドとして「ネイティブ」のUIとやりとりする部分があるが、ネイティブUIのことはあんまり使わず、たとえば全部描画するし入力イベントも自分でハンドルしている（あとChromeOSは「ネイティブ」レイヤが基本的には存在しないので、viewsのバックエンドのようなものを全部作っている）。viewsは、正直にいうとあんまり出来がよくなく、ChromeのUIで動くところしかきちんとできてなかったりということがよくある。が、自分としては一通りわかっていて（頻繁に変わるのでいつでも再確認しないといけないのだが）それなりに読んだり細かい修正をしてきたので愛着もある。内製なので好き勝手に変更できるのはメリットではある。そんなメリットは喧伝すべきかどうかわからないけど。
逆側の話、つまりChromiumそのものやその一部をライブラリ化したり再利用したい、みたいな話もあるけど、こちらもそうそう再利用していない。Chromiumのレンダリングエンジンであるblinkは、その前身であるWebKitと大きく異なり、ライブラリ化されていない。Chromiumについているcontent/というレイヤを介さない限りは使えない。結果として、WebKitベースのブラウザはありうるけど、blinkベースのブラウザというものはほとんどなく、Chromiumをベースにしたブラウザというものになっている。
また、Chromiumのbase/というディレクトリはなかなかいいように思うけど外部で利用できないか、というリクエストはたまにあったのだが、毎回にべもなく断っていた。Chromiumプロジェクトとしては自分たちの都合で好き勝手にいろいろ足したいし、後方互換性のこととかを考えたりしたくない、Chromiumのためのものなので他では勘弁な、という話になっている。これははっきりいって感じが良くないのだが、そういうことをしたくないという気持ちはよくわかる。汎用のライブラリを作ってるわけじゃないのにそんなことを要求されても困る、という話でもある。が、abseilができてからは、こういうリクエストはほぼなくなった気がする。C++も発展が進んだので、いまどきChromiumのbaseがほしい人間なんていやしないのだった。よかったよかった（？）
なおChromeOS側のサービスなどの実装のためにChromiumのbase相当のものがほしいという話が根強くあり、baseを勝手にコピーしてライブラリ化して使っている。一見再利用っぽく聞こえるかもしれないけれど、別にそういうわけでもない。勝手にコピーしてるだけだし。たまにChromiumの最新のものに更新するたびに大変な作業になっているつらさとかを垣間見るに、再利用を避けるポリシーを徹底したことの弊害が感じられないでもない。
というわけで、仕事のほうではあんまりちゃんと再利用していない昔ながらのプロジェクトをやっているので、それがどんな感じなのかを書いてみた。
この状況は、再利用がごくふつうな他の言語と比べるとかなり乖離があるが、そうなっていることにはそれなりに理由があるときもある。たとえばbaseが一般化されたライブラリになっていないのは、そういうことを指向していないからだ。専用のGUIフレームワークは、ChromeのUIで必要になりそうなところだけがよく書けていて、それ以外の部分は意外に雑なつくりになっていたりする。そういうものを使おうとすると、けっきょくそういう雑な部分を自分で書く必要が出てきたり、ということがよくある。これは残念なライブラリという見方もできるけれど、視点を変えれば、汎用のものは目指さない指向という意味では一貫している。
が……よく考えてみると、けっきょくこれは「C/C++では再利用が大変だ」という話の言い換えでしかないような気もする。再利用が大変であるがゆえに内製もしがちだし、パッケージとして公開するのもかんたんじゃないから公開しない。 後方互換性とかもべつに考えたくないけどそのための解決策もとくになかった。
他の言語だと、再利用が難しいとかできないっていうことは、みんなあんま考えてる気がしない。が、これはなんというか、パッケージシステムとかビルドシステムによって解決されてきた問題なような気がする。だいたいnpm installすればいいでしょ、go getすればいいでしょ、nuget&amp;hellip;cargo&amp;hellip;みたいな。C/C++にはこのレイヤの（デファクト）スタンダードがなんにもないから解決していない。しかしいまさらそんなのは望むべくもない。残念ですね、という話なような気がしてきた。
ところで逆な例でいえば、Node.js (NPM)とかを見ると「さすがに他人のコードに依存しすぎでしょ」という揺り戻しはたまに起きてる気がするし（たとえば文字列に空白を埋めるだけのライブラリが破綻を引き起こした事件とか）、lodashに依存するな問題とか、そういうのはある。もちろんこういうのは程度問題でしかなくて、再利用を一切しないっていうことはさすがに考えていないだろうけど、再利用しすぎの問題ってのも、それはそれで顕在化はしてると思う。
 morrita  ここがすでに独自なのかよ、というツッコミがあるかもしれませんがスルーしてください
 でもビルドシステムの揃っていなさはコミュニティとしての合意の無さのあらわれという気はする・・・。 Chromium はオープンソースでありながらあんなに再利用に不親切で、 その一方で互換ブラウザや Electron みたいのが沢山あって、興味深いですね。
あと Chrome/Chromium コードベース本体はともかく、Chrome 製品の一環として開発されているライブラリたちは割と広く使われているので、 捨てたものではない、かもしれない。(V8, Skia, Webp, PDFium&amp;hellip;)
  karino2 Electronなんかを見ていると、再利用をしてもらうのに一番大切なのは再利用をするに値する価値ある物を作る、という事なんだろうなぁ、と思う。
ネイティブのweb viewを使ったもっと小さなelectron alternativesの試み、いっぱいあっていろいろ評価してみたのだけれど、評価すればするほどChromium良く出来てるな、という思いを強くしただけだった。</description>
    </item>
    
    <item>
      <title>再利用の 15 年くらい</title>
      <link>https://messagepassing.github.io/014-reuse/03-morrita/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/014-reuse/03-morrita/</guid>
      <description>ソフトウェアの再利用が難しい・・・というか難しかったというのは歴史的には事実で, たとえば ICSR / International Conference on Software Reuse とかいう学会がある。 どんな論文が書かれていたのか検索すると 2005 年の Software Reuse Research: Status and Future という論文が 950 citation くらい。もっと引用されている同系統の論文もないではないけど古すぎるので割愛し、 この論文をざっと眺めてみると・・・そういうのあったわーという単語がいっぱい出てくる。COM とかね。 (知らない人向けに補足すると COM というのは C++ で Java みたいなことをしたくて色々苦し紛れにがんばったテクノロジだとご理解ください。）
この頃のソフトウェア再利用、色々厳しい雰囲気が論文をチラ見するだけで伝わってくる。 今から考えるとムリっぽい暗黙の前提があると思う。三つくらいに分けて雑に整理してみたい。
ひとつ目の前提: ソースコードが非公開。 この頃はまだコードは出さないのが普通。
コードが見られなかったらそりゃ再利用大変でしょ。 エラーがおきても原因を調べられないし、ワークアラウンドもできないじゃん。
しかも形態が共有ライブラリだったりする。HTTP でプロセス境界を切ったりしない。 いちおう分散コンピューティングはあったが EJB とか CORBA とか DCOM とかの分散オブジェクトがマインドシェアを持っていた。 こいつらはマジ密結合で厳しく、SOAP だなんだと退化して結局 REST くらいに落ち着いたのを我々は事後的に知っている。
ふたつ目の前提: 再利用に課金したい。 ソフトウェア、仕事で書いてるので再利用したらちゃんと現金で対価をで払ってほしいと思っていた。
でもね、ライブラリでカネとるとか相当大変。現代でも数少ない例外を除き基本的にはできていない。 金をとりたいからひとつ目のソースコード非公開が必要なのだけれど、 使う側からするとそんなブラックボックスにわざわざ金払ってロックインされたくない。悪循環。 (じっさい成功しているライブラリ業者はソースコードも提供していることが多い。)
しかも昔はライブラリを作る側も使う側もソフトウェアのリリース・デプロイが頻繁じゃなかったので、 課金も subscription based ではなく買い切りだった。なので質が高いほど継続的な集金が難しい。 純粋な技術的障壁だけでなく、ビジネスモデルが辛い。
みっつ目の前提: 方法論があればなんとかなる。 2000 年代前半って、ソフトウェア工学といえばプロセス、開発方法論というような雰囲気があった(例: RUP)。 方法論というとちょっと限定的すぎで、たとえば形式化手法とか標準化とか、そういうやつね。 良い方法論と、そのためのツールを整備すれば再利用含め色々なことが上手くいく・・・といいな・・・と人々は期待していた。 先の論文でも chapter 6 によくわかんない methodology が列挙されている。(著者のバイアスな気もするが・・・)</description>
    </item>
    
    <item>
      <title>パッケージマネージャー世代</title>
      <link>https://messagepassing.github.io/014-reuse/02-kzys/</link>
      <pubDate>Thu, 04 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/014-reuse/02-kzys/</guid>
      <description>何故プログラムの再利用というのが難しかったのか、という話をしていたら、「えっ？別に難しくないですよね？」とkzysに言われて、ちょっとその辺の話をしてみたくなった。
 我ながら若者らしい発言。
ただ C/C++ でも、Linux だと pkg-config　や so ファイルの名前づけルール、apt-get とかのパッケージマネージャーのおかげである程度ビルド周りの話は解決していて、結果として他ライブラリを色々使うソフトウェアがあった気がする。GNOME なアプリを入れたら依存で色々入ったりしませんか? クロスプラットフォームだと確かに大変そう。
私は、アルバイトじゃない最初の仕事がミクシィで、ソーシャルネットワーキングサービスのミクシィはいわゆる LAMP (Linux + Apache + MySQL + Perl) スタック、そのあとも全体的に C/C++ とかは使わず、Linux だけを気にするサーバーサイド仕事が多かったので「再利用できない」という感覚はあまりない。MySQL や memcached みたいなオープンソースなミドルウェアと、CPAN ないし、その言語についてるパッケージマネージャーからダウンロードできるライブラリを組み合わせてソフトウェアを作るのが普通。
ライブラリの再利用と、フレームワークの再利用 ミクシィ世代の会社には、それでも自社 Web アプリケーションフレームワークというものを見かける機会がまだあって、オープンソースになっているものだと、例えばライブドアには Sledge, はてなには Ridge, GREE には、これは CTO の藤本さんがもともと開発していたものなので、自社フレームワークと呼ぶのは語弊があるけれど、Ethna があった。
その後のクックパッド世代になると、Rails や Django といった既製のフルスタックなフレームワークを使うのが普通になってしまって、Web アプリケーションフレームワークを自作するのは、よっぽどわかっているか、よっぽどわかっていないか、どちらかじゃないとやらない、普通じゃない選択肢になってしまったという感がある。
とはいえこれも一昔前の話で、最近のモバイルアプリとシングルページアプリケーション世代の「サーバーで生成するのは JSON だけでいいですよ」という人々が何を使っているのかというと、うーん、なんなんだろう。私はここらへんの仕事をしたことがないのでコメントは控えます。
最近にみかけた再利用 自分のいまの仕事の周辺でいうと、例えば containerd には ttrpc というオレオレ RPC を使っているんだけど、これはセマンティクスは gRPC で、IDL もそのまま proto3 を再利用している。Firecracker の API は RPC ではなく REST だけど、IDL は OpenAPI で定義されている。みんな色々と再利用できていてえらいなーという感じ。</description>
    </item>
    
    <item>
      <title>再利用のはなし</title>
      <link>https://messagepassing.github.io/014-reuse/01-karino2/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://messagepassing.github.io/014-reuse/01-karino2/</guid>
      <description>何故プログラムの再利用というのが難しかったのか、という話をしていたら、「えっ？別に難しくないですよね？」とkzysに言われて、ちょっとその辺の話をしてみたくなった。
個人的にソフトウェアの再利用が一般的と感じられるようになったのは、JavaでJakartaが有用なライブラリを揃え始めた頃からだ。 再利用される方の話は現代の普通の話なので良いと思う。 ではそれ以前の何が難しかったのか、と思うと、CやC++の難しさが多い気がしてきた。
C++の再利用が何故難しいのか、という話をすると長くなる上に今更なので、 今のプロジェクトでさしあたってうまく行かないと感じる、今、目の前の問題だけを書いてみたい。
共通のプリミティブが無い難しさ 例えばスレッド周りの何かのライブラリを再利用したい、と考えたとする。 この時、Win32 APIの同期プリミティブとQtの同期プリミティブとSTLの同期プリミティブとpthreadの同期プリミティブは、同じ機能を提供するが、相互に取り替えて動く保証が無い（あるかもしれないし幾つかの組み合わせはある事も知っているが、一般にあるか無いかを判定するのはかなり難しいし、幾つかの組み合わせは怪しいのも知っている）。 QtでGUIとタイトに相互作用するような所で使いたい場合、 Qtの並列プリミティブで無いと困ってしまう。
その結果、いろいろな環境で動く、スレッドプールを前提としたノンブロッキングなFuture、 みたいなライブラリを作るのは、なかなか難しい。STLのスレッド前提のものは作れるのだけれど。
Win32 APIやQtが、現在のSTLを元に作られていれば、こういう問題はなかったとは思う。 でもどちらもSTLのスレッドより以前から作られていた物だし、そういう物はまだまだ世の中多い。
STLにまだ入ってない物も多い。今更filesystem周りが入った、という事からもそれがわかる。
Javaや.NETなどの環境や、pythonなどの普通のLLには、 ベースと出来る範囲がずっと広く、それらに依存した物は普通にどこでも動く。 言語の標準となる機能の範囲がC++は狭い。特にどの環境でも使えるC++のバージョンに限定すると、さらに狭い。
歴史をなかなか無かった事に出来ない そろそろVSもXcodeもNDKもQtもすべての環境がCMakeになって、 最初からconanをサポートして、 最新のSTLにあるものはSTLを、boostにあるものはboostを使ってくれて、 STLのスレッドや並列周りもfollyの奴くらいにいい感じのになってくれればいいのでは、 という気はするのだけれど、今からそうはなってくれない。（なってくれていいのよ？）
過去の歴史はそのままに、CMakeでもプロジェクトファイルが生成出来ます、 みたいなのだと、どうしてもバージョンアップなどのトラブルで後手に回ってしまう。 残念な事にC++が相手にするような環境のうちの幾つかは十分なサポートがされてなく、 自分たちでどうにかせざるをえない事も多い。 こういう時に何かが一段その環境のネイティブな仕組みの間に挟まってると、 メンテがすごく大変になる。 公式の側がCMakeになってくれればそういう問題も無いのだが…
手元のコードベースの側も、過去のいろいろなプラットフォーム上での様々な固有事情を踏まえたプロジェクトファイルやらビルドの仕組みを内包していて、全てを新しい仕組みに移動するのもなかなか大変。
本来は最新版だけがきっちりサポートされてればいいはずなのだけど、メジャーバージョンアップをするとめちゃくちゃ不安定になって特定のバージョンで止めなきゃいけないみたいなくされ環境があり、 その環境がサポートしているコンパイラはちょっと古くて最新のC++機能が使えなかったりとかがあり、 いろいろな事情でVC2008もサポートしないと駄目とかがあり、 内輪の事情で特定のRHELでビルド出来ないと駄目とかもあり… みたいな、プロジェクト固有の事情からもなかなか脱却出来ず、 「本来はこうあるべき」という姿になかなか出来ない。
他への依存をみんなしたがらない おのおのが歴史を持ったプロジェクトに使ってもらう事を考えると、ライブラリ作者は使う側のビルド環境などを想定出来ないので、他のライブラリへの依存の仕方も難しい。 「このライブラリを動かす為には、ライブラリAとライブラリBとライブラリCを適切に設定してパスをXXXで通るようにしてください」 みたいな事をお願いすると、使ってもらうのもきびしい。
なので複数のライブラリに依存したライブラリを使ってもらうのはすごく大変。
結果として、STLとboostのヘッダオンリーな物あたりだけに依存したライブラリくらいしか使いたくない。
コデックとかflatbuffersとか他への依存が少ない小粋なライブラリは使えるのだけれど、 ノンブロッキングなfutureを返すhttpのライブラリ、 とか、ノンブロッキングなfutureを返すノンブロッキングioなファイル周りのライブラリ、 のように、他の結構大きな物に依存するライブラリは全然ない。
そもそもライブラリが言うほど無い 「iOSならGCD、WindowsやQtならシステムのスレッドプール、 AndroidならSTLあたりで書かれた自前実装のスレッドプールを使ったExecutor」程度のライブラリも存在しない。
Windowsのフルな機能にアクセス出来る、Direct2DあたりをベースにしたモダンなGUIライブラリ、程度のものも無い（xi-editor retrospectiveでも、There is no such thing as native GUIと言っている）。WTLをforkして自前で作るか？と思うくらい無い。
WindowsのAsync IOとOS XのDispatch SourceとLinuxのepoll周りを吸収してよ、くらいでも普通に無い（このくらいなら頑張って探せばあるかもしれない、自分は見つけられなかったが）。
「インテリセンスを壊さない」UnitTestライブラリ、程度でも見つけられなかった（仕方ないので自作した）。
みんな似たような物作っているくせに、全然再利用出来るものが無い。
kzys  WindowsのAsync IOとOS XのDispatch SourceとLinuxのepoll周りを吸収してよ、くらいでも普通に無い（このくらいなら頑張って探せばあるかもしれない、自分は見つけられなかったが）。</description>
    </item>
    
  </channel>
</rss>
